<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音のデジタル化シミュレーター</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px; background: #e2e8f0; border-radius: 9999px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb,
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: #4f46e5; border-radius: 9999px; cursor: pointer;
        }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 20px; margin-right: 10px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider-round { position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider-round:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-round { background-color: #4f46e5; }
        input:focus + .slider-round { box-shadow: 0 0 1px #4f46e5; }
        input:checked + .slider-round:before { transform: translateX(20px); }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-4 md:p-8">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-6">
            PCM(パルス符号変調Pulse Code Modulation）シミュレータ
        </h1>

        <div class="flex flex-col lg:flex-row gap-6">
            <div class="lg:w-1/3 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4 text-indigo-700">設定を変更して遊んでみよう</h2>

                <div class="mb-6">
                    <label for="sampling-slider" class="block font-bold text-gray-700">Step 1: 標本化 (Sampling)</label>
                    <p class="text-sm text-gray-600 mb-2">波をスキャンする細かさ（標本化周波数）を決めます。値が大きいほど、細かくスキャンします。</p>
                    <input type="range" id="sampling-slider" min="5" max="100" value="5" class="w-full">
                    <div class="text-center text-indigo-600 font-semibold mt-2" id="sampling-label">20 サンプル</div>
                </div>

                <div class="mb-6">
                    <label for="bits-slider" class="block font-bold text-gray-700">Step 2: 量子化 (Quantization)</label>
                    <p class="text-sm text-gray-600 mb-2">波の高さを表現する精度（量子化ビット数）を決めます。ビット数が多いほど、高さを細かく表現できます。</p>
                    <input type="range" id="bits-slider" min="1" max="8" value="1" class="w-full">
                    <div class="text-center text-indigo-600 font-semibold mt-2" id="bits-label">3 ビット (8 段階)</div>
                </div>

                <div class="mb-6">
                    <h3 class="font-bold text-gray-700 mb-3">表示オプション</h3>
                    <div class="flex items-center mb-2">
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-analog-wave" checked>
                            <span class="slider-round"></span>
                        </label>
                        <span class="text-sm text-gray-700">元のアナログ波</span>
                    </div>
                    <div class="flex items-center mb-2">
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-x-projection" checked>
                            <span class="slider-round"></span>
                        </label>
                        <span class="text-sm text-gray-700">標本点のX軸への射影</span>
                    </div>
                    <div class="flex items-center mb-2">
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-y-projection">
                            <span class="slider-round"></span>
                        </label>
                        <span class="text-sm text-gray-700">量子化レベルのY軸への射影</span>
                    </div>
                    <div class="flex items-center mb-2">
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-quantized-wave">
                            <span class="slider-round"></span>
                        </label>
                        <span class="text-sm text-gray-700">デジタル化された波形（階段）</span>
                    </div>
                </div>

                <div>
                    <h3 class="font-bold text-gray-700 mb-2">グラフの見方</h3>
                    <ul class="space-y-2 text-sm">
                        <li class="flex items-center"><span class="w-4 h-1 bg-blue-500 inline-block mr-2 rounded"></span>元のアナログ波</li>
                        <li class="flex items-center"><span class="w-4 h-1 bg-red-500 inline-block mr-2 rounded"></span>デジタル化された波形</li>
                        <li class="flex items-center"><span class="w-2 h-2 bg-red-500 inline-block mr-2 rounded-full"></span>標本化された点</li>
                        <li class="flex items-center"><span class="w-px h-3 border-l border-dashed border-red-400 inline-block mx-1 mr-2"></span>標本点のX軸への射影</li>
                        <li class="flex items-center"><span class="w-4 h-0.5 border-t border-dashed border-red-400 inline-block mr-2"></span>量子化レベルのY軸への射影</li>
                    </ul>
                </div>
            </div>

            <div class="lg:w-2/3 bg-white p-6 rounded-lg shadow-md">
                <div class="aspect-w-2 aspect-h-1 w-full">
                    <!-- キャンバスは黒背景 -->
                    <canvas id="wave-canvas" class="w-full h-full bg-black"></canvas>
                </div>

                <div class="mt-6">
                    <h2 class="text-xl font-bold mb-2 text-indigo-700">Step 3: 符号化 (Encoding)</h2>
                    <p class="text-sm text-gray-600 mb-3">量子化された各点の「高さレベル」を、0と1の2進数コードに変換します。これがデジタルデータです。</p>
                    <div class="bg-gray-100 p-4 rounded-md">
                        <p class="font-mono text-sm text-gray-800 break-words" id="binary-output"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('wave-canvas');
    const ctx = canvas.getContext('2d');

    const samplingSlider = document.getElementById('sampling-slider');
    const bitsSlider = document.getElementById('bits-slider');
    const samplingLabel = document.getElementById('sampling-label');
    const bitsLabel = document.getElementById('bits-label');
    const binaryOutput = document.getElementById('binary-output');

    const toggleAnalogWave = document.getElementById('toggle-analog-wave');
    const toggleXProjection = document.getElementById('toggle-x-projection');
    const toggleYProjection = document.getElementById('toggle-y-projection');
    const toggleQuantizedWave = document.getElementById('toggle-quantized-wave');

    let padding = 40; // 軸ラベルのための余白

    function getAnalogValue(t) {
        const freq1 = 2, freq2 = 7;
        const amp1 = 0.35, amp2 = 0.15;
        return 0.5 + Math.sin(t * freq1 * 2 * Math.PI) * amp1 + Math.sin(t * freq2 * 2 * Math.PI) * amp2;
    }

    function draw() {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        const graphWidth = canvas.width - padding * 2;

        const y_px_level_max = padding;                 // level (N-1)
        const y_px_level_min = canvas.height - padding; // level 0
        const graphHeight_levels = y_px_level_min - y_px_level_max;

        const numSamples = parseInt(samplingSlider.value);
        const numBits = parseInt(bitsSlider.value);
        const numLevels = Math.pow(2, numBits);
        const levelHeight_px = (numLevels > 1) ? graphHeight_levels / (numLevels - 1) : 0;

        samplingLabel.textContent = `${numSamples} サンプル`;
        bitsLabel.textContent = `${numBits} ビット (${numLevels} 段階)`;

        // 背景を黒で塗る
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 軸（白）
        ctx.beginPath();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.moveTo(padding, padding / 2);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.moveTo(padding, y_px_level_min);
        ctx.lineTo(canvas.width - padding / 2, y_px_level_min);
        ctx.stroke();

        // 軸ラベル（白）
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('時間 (s)', padding + graphWidth / 2, canvas.height - padding / 4);
        ctx.save();
        ctx.translate(padding / 2, padding + graphHeight_levels / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('電圧 (V)', 0, 0);
        ctx.restore();

        // Y軸の短い目盛線（白）
        ctx.beginPath();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        for (let level = 0; level < numLevels; level++) {
            const y_px_center = y_px_level_min - level * levelHeight_px;
            ctx.moveTo(padding - 5, y_px_center);
            ctx.lineTo(padding, y_px_center);
        }
        ctx.stroke();

        // アナログ波（青）
        if (toggleAnalogWave.checked) {
            ctx.beginPath();
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            for (let x_px = 0; x_px <= graphWidth; x_px++) {
                const t = x_px / graphWidth;
                const y_val = getAnalogValue(t);
                const y_px = y_px_level_min - y_val * graphHeight_levels;
                if (x_px === 0) ctx.moveTo(padding + x_px, y_px);
                else ctx.lineTo(padding + x_px, y_px);
            }
            ctx.stroke();
        }

        // Y軸の2進ラベル（白）
        if (numBits <= 5) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Inter';
            ctx.textAlign = 'right';
            for (let level = 0; level < numLevels; level++) {
                const y_px_center = y_px_level_min - level * levelHeight_px;
                const binaryString = level.toString(2).padStart(numBits, '0');
                ctx.fillText(binaryString, padding - 8, y_px_center + 3);
            }
        }

        const sampleStep_px = graphWidth / (numSamples - 1);
        let digitalPoints = [];
        let binaryStrings = [];

        const dashPattern = [2, 3];
        const dashLength = dashPattern.reduce((a, b) => a + b, 0);
        const yProjectionDashOffset = padding % dashLength;

        for (let i = 0; i < numSamples; i++) {
            const x_px = padding + i * sampleStep_px;
            const t = (i * sampleStep_px) / graphWidth;

            const analogY_val = getAnalogValue(t);
            const analogY_px = y_px_level_min - analogY_val * graphHeight_levels;

            // 標本点（白に変更）
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x_px, analogY_px, 4, 0, 2 * Math.PI);
            ctx.fill();

            // X軸への射影（白の半透明に変更）
            if (toggleXProjection.checked) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 3]);
                ctx.moveTo(x_px, analogY_px);
                ctx.lineTo(x_px, y_px_level_min);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 量子化
            const level_float = analogY_val * (numLevels - 1);
            let level = Math.round(level_float);
            const quantizedY_px = y_px_level_min - level * levelHeight_px;
            digitalPoints.push({ x: x_px, y: quantizedY_px });

            // Y軸への射影（白の半透明に変更）
            if (toggleYProjection.checked) {
                if (i === 0 || (i > 0 && quantizedY_px !== digitalPoints[i - 1].y)) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash(dashPattern);
                    ctx.lineDashOffset = yProjectionDashOffset;
                    ctx.moveTo(x_px, quantizedY_px);
                    ctx.lineTo(padding, quantizedY_px);
                    ctx.stroke();
                    ctx.lineDashOffset = 0;
                    ctx.setLineDash([]);
                }
            }

            // 符号化
            let binaryString = level.toString(2).padStart(numBits, '0');
            binaryStrings.push(binaryString);
        }

        // 階段波形（赤のまま）
        if (toggleQuantizedWave.checked) {
            ctx.beginPath();
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            if (digitalPoints.length > 0) {
                let currentY_px = digitalPoints[0].y;
                ctx.moveTo(padding, currentY_px);
                ctx.lineTo(digitalPoints[0].x, currentY_px);
                for (let i = 0; i < digitalPoints.length; i++) {
                    const curr = digitalPoints[i];
                    let nextX_px = (i + 1 < digitalPoints.length) ? digitalPoints[i + 1].x : padding + graphWidth;
                    ctx.lineTo(nextX_px, curr.y);
                    if (i + 1 < digitalPoints.length) {
                        const nextY_px = digitalPoints[i + 1].y;
                        ctx.lineTo(nextX_px, nextY_px);
                    }
                }
            }
            ctx.stroke();
        }

        binaryOutput.textContent = binaryStrings.join(' ');
    }

    samplingSlider.addEventListener('input', draw);
    bitsSlider.addEventListener('input', draw);
    toggleAnalogWave.addEventListener('change', draw);
    toggleXProjection.addEventListener('change', draw);
    toggleYProjection.addEventListener('change', draw);
    toggleQuantizedWave.addEventListener('change', draw);

    new ResizeObserver(draw).observe(canvas.parentElement);
    draw();
});
</script>
</body>
</html>
